import PE007, math

"""
The sequence of triangle numbers is generated by adding the natural numbers.
So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28.
The first ten terms would be: 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...

Let us list the factors of the first seven triangle numbers:

 1: 1
 3: 1,3
 6: 1,2,3,6
10: 1,2,5,10
15: 1,3,5,15
21: 1,3,7,21
28: 1,2,4,7,14,28
36: 1,2,3,4,6,9,12,18,36

We can see that 28 is the first triangle number to have over five divisors.

What is the value of the first triangle number to have over five hundred
divisors?
"""


def genTriangle():
    """
    Generator of triangle numbers: 1(+2), 3(+3), 6(+4), 10(+5), 15...
    :return: next triangle number starting from 1
    """
    add = 1
    result = 0
    while True:
        result += add
        yield result
        add += 1


def getDivisors(n, divisors='nothing'):
    """
    Get all divisors of number n
    :param int n: number for which to get divisors
    :param list divisors: list of factors of previous number. The n must
           be divisible by all of factors in the list
    :return: list of all factors of number 'n'
    :rtype: list
    """
    if divisors == 'nothing':
        divisors = []
    else:
        divisors = divisors[:]
    for divisor in range(1, int(math.sqrt(n)) + 1):
        if n % divisor == 0 and divisor not in divisors:
            divisors.append(divisor)
            divisors.append(n // divisor)
    return sorted(divisors)

def findTriangleDivisors(limit):
    """
    Finds triangle number having at least 'limit' divisors
    :param int limit: limit of divisors
    :return: Triangle number which have as least 'limit' divisors
    :rtype: int
    """
    divDic = {}
    for triNo in genTriangle():
        maxkey = 1
        for key in divDic:
            if triNo % key == 0 and triNo > maxkey:
                maxkey = key
        if len(divDic) > 0:
            divisors = getDivisors(triNo, divDic[maxkey])
        else:
            divisors = getDivisors(triNo)
        # add new divisors into the dict
        divDic[triNo] = divisors
        if len(divisors) >= limit:
            return triNo, divisors


# for i in genTriangle():
#     print(i, getDivisors(i))
#     if i >= 100:
#         break


# print(findTriangleDivisors(500))
# print(getDivisors(36))


def divisors(n):
    # get factors and their counts
    # counts of how many times is n divisible by i
    factors = {}
    nn = n
    i = 2
    # same as while i <= sqrt(n), because higher factors are already
    # included after division by the lower factor
    while i*i <= nn:
        # check is nn is divisible by i
        while nn % i == 0:

            factors[i] = factors.get(i, 0) + 1
            # print(i, factors[i])
            nn //= i
        i += 1
    # print(factors)
    if nn > 1:
        factors[nn] = factors.get(nn, 0) + 1

    primes = list(factors.keys())

    # generates factors from primes[k:] subset
    def generate(k):
        if k == len(primes):
            yield 1
        else:
            rest = generate(k+1)
            prime = primes[k]
            for factor in rest:
                prime_to_i = 1
                # prime_to_i iterates prime**i values, i being all possible exponents
                for _ in range(factors[prime] + 1):
                    yield factor * prime_to_i
                    prime_to_i *= prime

# in python3, `yield from generate(0)` would also work
    for factor in generate(0):
        yield factor


div = []
for i in divisors(156):
   div.append(i)
print(div)
